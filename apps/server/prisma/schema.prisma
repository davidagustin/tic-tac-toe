generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ─── User ──────────────────────────────────────────

model User {
  id           String    @id @default(cuid())
  email        String    @unique
  passwordHash String?   // null for OAuth-only users
  name         String    @unique
  avatarUrl    String?
  rating       Int       @default(1000)
  gamesPlayed  Int       @default(0)
  wins         Int       @default(0)
  losses       Int       @default(0)
  draws        Int       @default(0)

  accounts     Account[]
  gamesAsX     Game[]    @relation("PlayerX")
  gamesAsO     Game[]    @relation("PlayerO")
  wonGames     Game[]    @relation("Winner")
  refreshTokens RefreshToken[]
  ratings      UserRating[]

  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  @@index([rating])
}

// ─── Per-Game Rating ──────────────────────────────

model UserRating {
  id          String   @id @default(cuid())
  userId      String
  gameType    GameType
  rating      Int      @default(1000)
  gamesPlayed Int      @default(0)
  wins        Int      @default(0)
  losses      Int      @default(0)
  draws       Int      @default(0)

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([userId, gameType])
  @@index([userId])
  @@index([gameType, rating])
}

// ─── OAuth Accounts ────────────────────────────────

model Account {
  id                String  @id @default(cuid())
  userId            String
  provider          String  // "google", "github"
  providerAccountId String

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@index([userId])
}

// ─── Refresh Tokens ────────────────────────────────

model RefreshToken {
  id        String   @id @default(cuid())
  token     String   @unique
  userId    String
  expiresAt DateTime
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

// ─── Game ──────────────────────────────────────────

model Game {
  id        String     @id @default(cuid())
  playerXId String
  playerOId String?    // null until opponent joins
  winnerId  String?
  roomId    String?    // Socket.IO room ID for tracing
  gameType  GameType   @default(TIC_TAC_TOE)

  status    GameStatus @default(WAITING)
  moves     Move[]

  playerX   User @relation("PlayerX", fields: [playerXId], references: [id])
  playerO   User? @relation("PlayerO", fields: [playerOId], references: [id])
  winner    User? @relation("Winner", fields: [winnerId], references: [id])

  startedAt DateTime @default(now())
  endedAt   DateTime?

  @@index([playerXId])
  @@index([playerOId])
  @@index([startedAt])
  @@index([roomId])
  @@index([gameType])
}

// ─── Move ──────────────────────────────────────────

model Move {
  id         String     @id @default(cuid())
  gameId     String
  player     PlayerMark
  position   Int?       // 0-8 for TTT, null for chess
  moveNum    Int

  // Chess-specific fields
  fromSquare String?    // e.g. "e2"
  toSquare   String?    // e.g. "e4"
  san        String?    // standard algebraic notation
  promotion  String?    // "q", "r", "b", "n"

  game Game @relation(fields: [gameId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@index([gameId])
  @@index([gameId, moveNum])
}

// ─── Enums ─────────────────────────────────────────

enum GameType {
  TIC_TAC_TOE @map("tic_tac_toe")
  CHESS       @map("chess")
}

enum GameStatus {
  WAITING     @map("waiting")
  IN_PROGRESS @map("in_progress")
  X_WINS      @map("x_wins")
  O_WINS      @map("o_wins")
  DRAW        @map("draw")
  ABANDONED   @map("abandoned")
  WHITE_WINS  @map("white_wins")
  BLACK_WINS  @map("black_wins")
}

enum PlayerMark {
  X
  O
  WHITE
  BLACK
}
